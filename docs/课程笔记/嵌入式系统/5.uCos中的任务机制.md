uCos-III中的任务机制
===

目录
---

[TOC]

## 1. 背景

老师上课讲到了uC/OS中的任务机制，所以我结合[《μC/OS-III源码分析笔记》](https://m.igetget.com/hybrid/v2/ebook/detail?bid=EJmMZXq1b8qOpBlD69XAdP7LEGaKJWEYBqWxRnme5vrVzo4QMZYgNyk2jNA5467K)想要写一篇笔记对这部分的内容进行总结。

## 2. 源码分析

### 2.1. 任务调度函数

首先看任务调度函数`OSSched()`

```cpp
void  OSSched (void)
 {
     CPU_SR_ALLOC();

     // 还在中断中，不能进行任务调度
     if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
         return;
     }

     // 调度器锁住了，不能进行任务调度
     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
         return;
     }

     // 关中断
     CPU_INT_DIS();
     // 找出就绪列表中优先级最高的任务的优先级
     OSPrioHighRdy   = OS_PrioGetHighest();
     // 找到该优先级下对应的第一个任务
     OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
     // 判断该任务是否跟当前运行任务是一样的
     if (OSTCBHighRdyPtr == OSTCBCurPtr) {
         CPU_INT_EN();
         return;
     }

 #if OS_CFG_TASK_PROFILE_EN > 0u
     // 被切换到的任务的切换次数加1
     OSTCBHighRdyPtr->CtxSwCtr++;
 #endif
     // 总得任务切换次数加1
     OSTaskCtxSwCtr++;

     // 调用任务切换的宏
     OS_TASK_SW();
     // 使能中断
     CPU_INT_EN();
 }
```

> 首先如果是在中断中或者调度器被锁住，就不能直接进行调度直接退出。中断的代码一般做的都是重要并且比较简单的事情，中断必须先执行完再去执行任务相关代码。如果在中断中进行任务调度，不仅仅会影响系统的实时性，中断服务程序不能及时运行，而且可能会产生异常（关于中断中进行任务切换引发的异常在网上有相关的文章——《破坏STM32中断机制引发的异常》进行分析，大家可以去看下）。

> 根据前面的第12章第13章关于就绪列表的知识很容易就找出就绪列表中哪一个优先级最高，且该优先级哪个任务应该进行切换执行，然后判断该任务是不是跟当前运行任务相同。如果相同就不用进行调度，如果不同先对任务切换的次数`OSTCBHighRdyPtr->CtxSwCtr`跟系统总的任务切换的次数`OSTaskCtxSwCtr`进行更新，接着执行调度，这个时候只是调用了宏`OS_TASK_SW()`。

> 有些读者可能会想，原来任务切换这么简单，就是调用了一个宏，看似简单的东西其实不简单，因为这个宏只是相当一个导火索，后面会“引爆”其他的操作。

### 2.2. 任务初始化函数

代码清单15-1 任务创建函数OSTaskCreate

```cpp
 void  OSTaskCreate (OS_TCB        *p_tcb,
                     CPU_CHAR      *p_name,
                     OS_TASK_PTR    p_task,
                     void          *p_arg,
                     OS_PRIO        prio,
                     CPU_STK       *p_stk_base,
                     CPU_STK_SIZE   stk_limit,
                     CPU_STK_SIZE   stk_size,
                     OS_MSG_QTY     q_size,
                     OS_TICK        time_quanta,
                     void          *p_ext,
                     OS_OPT         opt,
                     OS_ERR        *p_err)
 {
     CPU_STK_SIZE   i;
 #if OS_CFG_TASK_REG_TBL_SIZE > 0u
     OS_OBJ_QTY     reg_nbr;
 #endif
     CPU_STK       *p_sp;
     CPU_STK       *p_stk_limit;
     CPU_SR_ALLOC();


 // 是否定义安全检查的宏
 #ifdef OS_SAFETY_CRITICAL
     if (p_err == (OS_ERR *)0) {
     // 如果传入的参数p_err是空指针，那么将进入安全关键异常，这部分需要用户自己编写
         OS_SAFETY_CRITICAL_EXCEPTION();
         return;
     }
 #endif

 // 是否启动安全关键
 #ifdef OS_SAFETY_CRITICAL_IEC61508
     /* 一旦调用OSSafetyCriticalStart，OSSafetyCriticalStartFlag就被置为36
       DEF_TRUE,不再允许创建内核对象。*/
     if (OSSafetyCriticalStartFlag == DEF_TRUE) {
         *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
         return;
     }
 #endif

 // 不能在中断中调用创建任务函数
 #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
         *p_err = OS_ERR_TASK_CREATE_ISR;
         return;
     }
 #endif

 // 进行参数检测
 #if OS_CFG_ARG_CHK_EN > 0u
     // 检测参数p_tcb是否为空指针
     if (p_tcb == (OS_TCB *)0) {
         *p_err = OS_ERR_TCB_INVALID;
         return;
     }

     // 检测参数p_task是否为空指针
     if (p_task == (OS_TASK_PTR)0) {
         *p_err = OS_ERR_TASK_INVALID;
         return;
     }

     // 检测参数p_stk_base是否为空指针
     if (p_stk_base == (CPU_STK *)0) {
         *p_err = OS_ERR_STK_INVALID;
         return;
     }

     // 堆栈至少应该大于我们设定的最小值OSCfg_StkSizeMin
     if (stk_size < OSCfg_StkSizeMin) {
         *p_err = OS_ERR_STK_SIZE_INVALID;
         return;
     }

     // 限制的堆栈大小肯定不能超过整个堆栈的大小
     if (stk_limit >= stk_size) {
         *p_err = OS_ERR_STK_LIMIT_INVALID;
         return;
     }

     // 任务优先级不能大于设置的最大优先级
     if (prio >= OS_CFG_PRIO_MAX) {
         *p_err = OS_ERR_PRIO_INVALID;
         return;
     }
 #endif


 // 如果允许延迟提交，那么优先级为0的任务是延迟提交的，任务不能设置为此优先级
 #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
     if (prio == (OS_PRIO)0) {
         if (p_tcb != &OSIntQTaskTCB) {
             *p_err = OS_ERR_PRIO_INVALID;
             return;
         }
     }
 #endif

     // 最低优先级为空闲任务，任务不能设置为此优先级
     if (prio == (OS_CFG_PRIO_MAX - 1u)) {
         if (p_tcb != &OSIdleTaskTCB) {
             *p_err = OS_ERR_PRIO_INVALID;
             return;
         }
     }

     // 初始化任务控制块
     OS_TaskInitTCB(p_tcb);

     *p_err = OS_ERR_NONE;

     // 创建任务的时候，如果有选项OS_OPT_TASK_STK_CHK和OS_OPT_TASK_STK_CLR，
     // 则从低地址开始将所有的堆栈空间初始化为0，后面可以计算最大的堆栈使用情况
     if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {
         if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {
             p_sp = p_stk_base;
             for (i = 0u; i < stk_size; i++) {
                 *p_sp = (CPU_STK)0;
                 p_sp++;
             }
         }
     }

 // 根据堆栈增长方向，计算限制堆栈的那个地址
 #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
     p_stk_limit = p_stk_base + stk_limit;
 #else
     p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
 #endif

     // 对堆栈进行初始化，初始化的内容将在第一次进行任务切换的时候恢复为寄存器的值
     // 最后返回初始化堆栈后返回堆栈指针。
     p_sp = OSTaskStkInit(p_task,
                          p_arg,
                          p_stk_base,
                          p_stk_limit,
                          stk_size,
                          opt);

     // 保存任务地址到任务控制块元素TaskEntryAddr
     p_tcb->TaskEntryAddr = p_task;

     // 保存任务参数到任务控制块元素TaskEntryArg
     p_tcb->TaskEntryArg  = p_arg;

     // 保存任务的名称到任务控制块元素NamePtr
     p_tcb->NamePtr       = p_name;

     // 保存任务的优先级到任务控制块元素Prio
     p_tcb->Prio          = prio;

     // 保存任务的堆栈指针到任务控制块元素StkPtr
     p_tcb->StkPtr        = p_sp;

     // 保存任务的堆栈限制增长地址到任务控制块元素StkLimitPtr
     p_tcb->StkLimitPtr   = p_stk_limit;


     // 保存任务的时间片到任务控制块元素time_quanta
     p_tcb->TimeQuanta    = time_quanta;

 // 允许进行时间片轮转调度
 #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
     // 如果设置时间片time_quanta为0，参数时间片计数值为默认的OSSchedRoundRobinDfltTimeQuanta
     // 为OSCfg_TickRate_Hz/10u，即100，否则为参数的设置。
     if (time_quanta == (OS_TICK)0) {
         p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
     } else {
         p_tcb->TimeQuantaCtr = time_quanta;
     }
 #endif

     // 保存任务的拓展内容到任务控制块元素ExtPtr，该参数为无确切类型指针
     p_tcb->ExtPtr        = p_ext;
     // 保存任务堆栈的低地址到任务控制块元素StkBasePtr
     p_tcb->StkBasePtr    = p_stk_base;
     // 保存任务堆栈的大小到任务控制块元素StkSize
     p_tcb->StkSize       = stk_size;
     // 保存任务创建时的选项到任务控制块元素Opt
     p_tcb->Opt           = opt;

 // 如果允许使用任务“寄存器”
 #if OS_CFG_TASK_REG_TBL_SIZE > 0u

     // 初始化任务的OS_CFG_TASK_REG_TBL_SIZE个“寄存器”都为0。
     // OS_CFG_TASK_REG_TBL_SIZE默认值为1
     for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
         p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
     }
 #endif

 // 如果允许使用任务消息队列
 #if OS_CFG_TASK_Q_EN > 0u

     // 初始化任务消息队列
     OS_MsgQInit(&p_tcb->MsgQ,
                 q_size);
 #endif

     // 调用任务创建时的回调函数OSTaskCreateHook，用户可以对函数
     // OS_AppTaskCreateHookPtr进行编写
     OSTaskCreateHook(p_tcb);

     OS_CRITICAL_ENTER();

     // 置就绪优先级位映像表中相应优先级处于就绪状态
     OS_PrioInsert(p_tcb->Prio);

     // 将新创建的任务插入就绪列表末尾
     OS_RdyListInsertTail(p_tcb);

 // 如果允许调试的宏（主要将各种内核对象串成双向链表，以方便调试）
 #if OS_CFG_DBG_EN > 0u
     // 就将任务添加到任务的双向链表中
     OS_TaskDbgListAdd(p_tcb);
 #endif

     // 更新任务数目
     OSTaskQty++;                          /* Increment the #tasks counter */

     // 只有系统启动了才开始后面的任务调度
     if (OSRunning != OS_STATE_OS_RUNNING) {
            // Return if multitasking has not started
         OS_CRITICAL_EXIT();
         return;
     }

     OS_CRITICAL_EXIT_NO_SCHED();

     // 进行任务调度
     OSSched();
 }
```

### 2.3. 任务挂起函数

代码清单15-2 任务挂起函数OSTaskSuspend

```cpp
 // 是否包含挂起任务或者取消挂起任务的相关代码
 #if OS_CFG_TASK_SUSPEND_EN > 0u
 void   OSTaskSuspend (OS_TCB  *p_tcb,
                       OS_ERR  *p_err)
 {
     CPU_SR_ALLOC();

 // 是否定义安全检查的宏
 #ifdef OS_SAFETY_CRITICAL
     if (p_err == (OS_ERR *)0) {
     // 如果传入的参数p_err是空指针，那么将进入安全关键异常，这部分需要用户自己编写
         OS_SAFETY_CRITICAL_EXCEPTION();
         return;
     }
 #endif

 // 中断中不允许调用任务挂起函数
 #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
         *p_err = OS_ERR_TASK_SUSPEND_ISR;
         return;
     }
 #endif

     // 不能挂起空闲任务
     if (p_tcb == &OSIdleTaskTCB) {
         *p_err = OS_ERR_TASK_SUSPEND_IDLE;
         return;
     }

 // 是否允许中断延迟提交
 #if OS_CFG_ISR_POST_DEFERRED_EN > 0u

     // 如果挂起的是中断延迟提交任务，则返回错误
     if (p_tcb == &OSIntQTaskTCB) {
         *p_err = OS_ERR_TASK_SUSPEND_INT_HANDLER;
         return;
     }
 #endif

     // 进入临界段
     CPU_CRITICAL_ENTER();

     // 如果p_tcb参数为空指针，则默认挂起的是当前任务
     if (p_tcb == (OS_TCB *)0) {
         p_tcb = OSTCBCurPtr;
     }

     // 如果挂起的是当前任务，后面就要进行任务调度，所以要检查调度器是否被锁住
     if (p_tcb == OSTCBCurPtr) {
         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
             CPU_CRITICAL_EXIT();
             *p_err = OS_ERR_SCHED_LOCKED;
             return;
         }
     }

     *p_err = OS_ERR_NONE;

     // 针对挂起任务的不同状态进行不同的处理
     switch (p_tcb->TaskState) {

     // 就绪状态
     case OS_TASK_STATE_RDY:

         /*在允许中断延迟的情况下，开中断并且锁住调度器，因为下面操作的变量
68         不可能在中断中被使用，所以只需要锁住调度器即可。如果不允许中断
69         延迟，这里会变成什么都不做，实际上这是个空宏，因为前面已经关中断*/
         OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();

         // 任务状态变为挂起状态
         p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;

         // 挂起的嵌套层数变为1，之前没有被挂起
         p_tcb->SuspendCtr = (OS_NESTING_CTR)1;

         // 将任务从就绪列表中脱离
         OS_RdyListRemove(p_tcb);

         // 退出临界段
         OS_CRITICAL_EXIT_NO_SCHED();
         break;


     // 延迟状态
     case OS_TASK_STATE_DLY:
         p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
         p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
         CPU_CRITICAL_EXIT();
         break;


     // 挂起的状态
     case OS_TASK_STATE_PEND:
         p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
         p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
         CPU_CRITICAL_EXIT();
         break;


     // 正在等待事件发生，并且有时间限制的时候
     // 注：OS_STATUS_PEND_TIMEOUT跟OS_TASK_STATE_PEND_TIMEOUT的含义不同
     case OS_TASK_STATE_PEND_TIMEOUT:
         p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
         p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
         CPU_CRITICAL_EXIT();
         break;


     // 之前已经是挂起状态，只需将嵌套层数+1
     case OS_TASK_STATE_SUSPENDED:
     case OS_TASK_STATE_DLY_SUSPENDED:
     case OS_TASK_STATE_PEND_SUSPENDED:
     case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
         p_tcb->SuspendCtr++;
         CPU_CRITICAL_EXIT();
         break;

     default:
         CPU_CRITICAL_EXIT();
         *p_err = OS_ERR_STATE_INVALID;
         return;
     }

     // 进行任务调度
     OSSched();
 }
 #endif
```

## 3. 参考文献

<div id="bib-1"></div>

[1] [李悦城. μC/OS-III 源码分析笔记. 机械工业出版社, 2016.](https://m.igetget.com/hybrid/v2/ebook/detail?bid=EJmMZXq1b8qOpBlD69XAdP7LEGaKJWEYBqWxRnme5vrVzo4QMZYgNyk2jNA5467K)
